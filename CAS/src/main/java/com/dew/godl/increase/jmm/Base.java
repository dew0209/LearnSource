package com.dew.godl.increase.jmm;

/**
 * jmm：
 *    java内存模型：jvm规范中试图定义一种java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异以实现让java程序在各种平台下都能达到一致的内存访问效果
 *    本身是一种抽象的概念并不真实存在，它仅仅描述的是一组规范或者约定，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量
 *    	的写入以及何时变成另一个线程可见。关键技术点都是围绕多线程的原子性，可见性和有序性展开的。
 *   原则：jmm的关键技术点都是围绕多线程的原子性，可见性和有序性展开的
 *   目的：1.实现线程和主内存之间的抽象关系 2.屏蔽各个硬件平台和操作系统的内存访问差异以实现java程序在各种平台下都能达到一致的内存访问效果
 *   可见性：
 *   	是指一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更。jmm规定了所有的变量都存储在主内存中
 *   	系统主存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现脏读，所以每个线程都有自己的工作内存，
 *   		线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的操作（读取，赋值等）都必需在线程自己的工作内存中
 *   		进行，而不能够直接读写主内存中的变量。不同线程之前也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过住内存来完成。
 *   原子性：
 *   	指一个操作是不可打断的，即多线程环境下，操作不能被其他线程干扰
 *   有序性：
 *  	对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但是为了提升性能，编译器和处理器通常会对指令序列进行
 *  		重新排序。java规范规定jvm线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，
 *  		此过程叫指令的重排序。
 *  	指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致
 *  	源代码--->编译器优化的重拍--->指令并行的重拍--->内存系统的重排--->最终执行的指令
 *  		编译器优化的重排序：编译器在不改变单线程串行语义的前提下，可以重新调整指令的执行顺序
 *  		指令级并行的重排序：处理器使用指令级并行技术来将多条指令重叠执行，若不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
 *  		内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行
 *
 *  小结：
 *  	1.我们定义的所有共享变量都存储在物理主内存中
 *  	2.我们每个线程都有自己独立的工作内存，里面保存该变成使用到的变量的副本（主内存中该变量的一份拷贝）
 *  	3.线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回到主内存，不能直接从主内存中读写
 *  	4.不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）
 *
 *  先行发生原则happens-before：
 *  	1.在jmm中，如果一个操作执行的结果需要对另一个操作可见性或者代码重排序，那么这两个操作之间必须存在happens-before（先行发生）原则
 *  	2.它是线程判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入java内存模型的底层编译原理之中
 *  	总原则：
 *  		如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个可见。
 *  			而且第一个操作的执行顺序排在第二个操作之前。
 *  		两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序去执行。
 *  			如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法
 *  	8条：
 *  		1.次序规则
 *  			一个线程内部，按照代码顺序，写在前面的操作优先发生于写在后面的操作
 *  			注意：一个线程内部
 *  		2.锁定规则：
 *  			一个unlock操作先行发生于后面（（这里的后面是指时间上的先后））对同一个锁的lock操作
 *  		3.volatile变量规则：
 *  			对于一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的后面同样是指时间上的先后
 *  		4.传递规则：
 *  			如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
 *  		5.线程启动规则：
 *				线程对象的start()方法先行发生于此线程的每一个动作
 *			6.线程中断规则：
 *				对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
 *				可以通过Thread.interrupted()检测是否发生中断
 *				也就是说你先要调用interrupt()方法设置过中断标志位，我才能检测到中断发生
 *			7.线程终止规则：
 *				线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行
 *			8.对象总结规则：
 *				一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
 *	happens-before的语义本质上是一种可见性
 *
 */
public class Base {
	static Object objectLock = new Object();

	private volatile int value = 0;

	public static void main(String[] args) {
		//对于同一把锁objectLock，threadA一定先unlock同一把锁后threadB才能获得该锁，A先行于B
		synchronized (objectLock){

		}
		Thread t1 = new Thread(() -> {
			System.out.println("------hello thread t1");
		}, "t1");
		t1.start();
	}

	public int getValue(){
		return value;//利用volatile保证读取操作的可见性
	}

	public synchronized int setValue(){
		return ++value;//利用synchronized保证复合操作的原子性
	}

}
