package com.dew.godl.increase.jmm;

/**
 * jmm：
 *    java内存模型：jvm规范中试图定义一种java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异以实现让java程序在各种平台下都能达到一致的内存访问效果
 *    本身是一种抽象的概念并不真实存在，它仅仅描述的是一组规范或者约定，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量
 *    	的写入以及何时变成另一个线程可见。关键技术点都是围绕多线程的原子性，可见性和有序性展开的。
 *   原则：jmm的关键技术点都是围绕多线程的原子性，可见性和有序性展开的
 *   目的：1.实现线程和主内存之间的抽象关系 2.屏蔽各个硬件平台和操作系统的内存访问差异以实现java程序在各种平台下都能达到一致的内存访问效果
 *   可见性：
 *   	是指一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更。jmm规定了所有的变量都存储在主内存中
 *   	系统主存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现脏读，所以每个线程都有自己的工作内存，
 *   		线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的操作（读取，赋值等）都必需在线程自己的工作内存中
 *   		进行，而不能够直接读写主内存中的变量。不同线程之前也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过住内存来完成。
 *   原子性：
 *   	指一个操作是不可打断的，即多线程环境下，操作不能被其他线程干扰
 *   有序性：
 *  	对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。但是为了提升性能，编译器和处理器通常会对指令序列进行
 *  		重新排序。java规范规定jvm线程内部维持顺序化语义，即只要程序的最终结果与它顺序化执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，
 *  		此过程叫指令的重排序。
 *  	指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致
 *  	源代码--->编译器优化的重拍--->指令并行的重拍--->内存系统的重排--->最终执行的指令
 *
 *  小结：
 *  	1.我们定义的所有共享变量都存储在物理主内存中
 *  	2.我们每个线程都有自己独立的工作内存，里面保存该变成使用到的变量的副本（主内存中该变量的一份拷贝）
 *  	3.线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回到主内存，不能直接从主内存中读写
 *  	4.不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能相互访问）
 *
 *  先行发生原则happens-before：
 *  	1.在jmm中，如果一个操作执行的结果需要对另一个操作可见性或者代码重排序，那么这两个操作之间必须存在happens-before（先行发生）原则
 *  	2.它是线程判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入java内存模型的底层编译原理之中
 *  	总原则：
 *  		如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个可见。
 *  			而且第一个操作的执行顺序排在第二个操作之前。
 *  		两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序去执行。
 *  			如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法
 *  	8条：
 *  		1.
 *
 */
public class Base {
	public static void main(String[] args) {

	}

}
